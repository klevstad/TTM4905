/*
	Adaptive Pairwise Key Establishment Scheme (APKES)
*/

usertype Index;

hashfunction MIC;

macro PairwiseKey = {Ru, Rv}k(U, V);
macro Hello = (Ru, SAu);
macro HelloAck = (Ru, Rv, Iuv, SAv);
macro HelloAckMIC = MIC(HelloAck,  k(U,V)); # Use PairwiseKey to achieve explicit key authentication?
macro Ack = (AckMsg, Ivu);
macro AckMIC = MIC(Ack, PairwiseKey);

const SAu; # U's Short Address
const SAv; # V's Short Address

const Iuv: Index; # U's index in V's list of neighbours
const Ivu: Index; # V's index in U's list of neighbours

const AckMsg;

protocol APKES(U, V)
{
	role U
	{
		fresh Ru: Nonce;
		var Rv: Nonce;

		#send_!0(U, U, k(U, V)); #To model if the adversary has obtained the preshared secret in LEAP.
		# HELLO
		send_1(U, V, Ru, SAu);

		# HELLOACK
		recv_2(V, U, HelloAck, HelloAckMIC);

		#ACK
		send_3(U, V, (Ack, AckMIC));
		
		# Claims:
		claim_U1(U, Alive); # V was "alive" as U was able to execute the protocol correctly
		claim_U2(U, Weakagree);
		claim_U3(U, Niagree); # Non-injective agreement
		claim_U4(U, Nisynch); # Non-injective synchronization
		claim_U5(U, Commit, V, Ru); # claim that the recv2 value of Ru has not been changed from the send_1 Ru-value
		claim_U6(U, Secret, PairwiseKey); # The pairwise key is kept secret from adversary


	}

	role V
	{
		fresh Rv: Nonce;
		var Ru: Nonce;

		# HELLO
		recv_1(U, V, Ru, SAu);
		claim_V6(V, Running, U, Ru); # To make sure that the Ru is not tampered with.

		# HELLOACK
		send_2(V, U, HelloAck, HelloAckMIC);

		# ACK
		recv_3(U,V, Ack, AckMIC);

		# Claims
		claim_V1(V, Alive);
		claim_V2(V, Weakagree);
		claim_V3(V, Niagree);
		claim_V4(V, Nisynch);
		claim_V5(V, Secret, PairwiseKey);

	}
}


