/*
Secure Authentication and Key Establishment Scheme (SAKES)
*/

hashfunction MAC;

const G; # Generator
const P; # Prime modulus

macro Message3-Cipher = {I, R, RS, Ni}k(I, S);
macro Message3 = (Message3-Cipher, I, Ni);
macro Message3-MAC = MAC(Message3, k(I, R), I, Ni);

macro Message4 = (Message3, R, Nr);
macro Message4-MAC = MAC(Message3, k(R, S), R, Nr);

macro Message5-Cipher = {I, R, RS}sk(S);
macro Message5 = {Ns,Message5-Cipher, pk(S), sk(S)}k(R, S);
macro Message6 = {R, Ns}k(I, S);

#macro Message7-MAC = MAC(Message5-Cipher, R, Nr, Pk);
#macro Message7 = {Message5-Cipher, Message7-MAC, R, Nr}Sk;

protocol SAKES(I, R, S, RS) {

	role I {
		# 6LoWPAN End Device (I)

		fresh Ni: Nonce;
		var Nr: Nonce;
		var Ns: Nonce;

		# HELLO
		send_1(I, R, Ni);
		recv_2(R, I, Nr);

		send_3(I, R, Message3, Message3-MAC);

		recv_6(S, I, Message6);

		claim_I1(I, Niagree);
		claim_I2(I, Nisynch);

		claim(I, Alive, R);
		claim(I, Alive, S);
		claim(I, Weakagree, R);
		claim(I, Weakagree, S);





	}

	role R {
		# 6LoWPAN Router (R)

		fresh Nr: Nonce;
		var Ni: Nonce;
		var Ns: Nonce;

		var Pk;
		var Sk;

		# HELLO
		recv_1(I, R, Ni);
		send_2(R, I, Nr);

		recv_3(I, R, Message3, Message3-MAC);

		send_4(R, S, Message4, Message4-MAC);

		#recv_5(S, R, {Ns, {I, R, S}sk(S), pk(S), sk(S)}k(R, S));
		recv_5(S, R, Message5);



		claim_R1(R, Niagree);
		claim_R2(R, Nisynch);

		claim_R3(R, Secret, sk(S));

		claim(R, Alive, I);
		claim(R, Alive, S);
		claim(R, Weakagree, I);
		claim(R, Weakagree, S);

		#send_7();
	}

	role S {
		# 6LoWPAN Border Router (S)

		fresh Ns: Nonce;
		var Nr: Nonce;
		var Ni: Nonce;

		const Pk: Function;
		secret Sk: Function;
		inversekeys (Pk, Sk);

		recv_4(R, S, Message4, Message4-MAC);

		#send_5(S, R, {Ns, {I, R, S}sk(S), pk(S), sk(S)}k(R, S));
		send_5(S, R, Message5);


		send_6(S, I, Message6);

		claim_S1(S, Niagree);
		claim_S2(S, Nisynch);

		claim(S, Alive, I);
		claim(S, Alive, R);
		claim(S, Weakagree, I);
		claim(S, Weakagree, R);
	}

	role RS {
		# Remote Server
	}


}
