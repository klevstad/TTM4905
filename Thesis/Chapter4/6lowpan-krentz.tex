\chapter{Adaptable Pairwise Key Establishment Scheme (APKES)}
\label{chp:krentz-6lowpan}


\gls{apkes} is a proposed protocol for handling key establishment and key management in \gls{6lowpan}. It is currently implemented in the operating system Contiki, which is an operating system targeted at the sensor network community, but has not undergone any formal security analysis. This chapter will cover its ideas, and conduct a formal security analysis using Scyther. 

\section{Introduction to APKES}

As previously described, \gls{6lowpan} is a protocol stack for integrating \gls{wsn}s running on 802.15.4 with \gls{ip}v6 networks, and enables the nodes in the network to communicate with each other or remote hosts over \gls{ip}. \gls{apkes} provides a framework for establishing pairwise keys for nodes in \gls{6lowpan} networks. The advantage with pairwise keys over other key schemes such as a network-shared key is related to node compromises. In \gls{6lowpan} networks, devices are often placed in potential hostile and unattended areas, greatly increasing the possibility of being tampered with by attackers. In the case of a network shared key, the whole network would be compromised in the event of a node compromise. Also, the attacker would be able to add new nodes to the network, as the upper-layer protocols rely on the 802.15.4 security sub-layer which is able to filter out replayed packets and prevent injection, but not discover node compromises \cite{krentz20136lowpan}. A solution to the tampering problem could be to construct tampering-proof nodes, but this is expensive and difficult, hence not a preferable solution \cite{anderson1996tamper}. Pairwise keys, however, would only compromise the communication going to or from that particular node. Figure \ref{fig:6lowpan-krentz} illustrates how \gls{apkes} is implemented at the link layer along with the 820.15.4 security sublayer.

\begin{figure}
	\centering
	\includegraphics[scale=0.80]{6lowpan-krentz.png}
	\caption{\gls{apkes} is positioned in the data link layer in the \gls{6lowpan} stack expanding the 802.15.4 security sublayer \cite{krentz20136lowpan}.}
	\label{fig:6lowpan-krentz}
\end{figure}

\gls{apkes} provides a ``pluggable'' key establishment scheme for \gls{6lowpan} networks using pairwise keys, where the developer of a \gls{6lowpan} network picks an appropriate key establishment scheme and delegates \gls{apkes} into handling the key establishment with other nodes \cite{krentz20136lowpan}. As there is really no superior scheme for \gls{6lowpan} networks, the use of pluggable schemes enhances the overall usability of the protocol, as the developer can use the most appropriate scheme based on the challenges he faces. The only function of the plugged-in scheme is to feed \gls{apkes} with the shared secret for communicating nodes, and \gls{apkes} will handle both key establishment and key management. Examples of pluggable schemes that has been suggested for \gls{apkes} are \gls{leap} \cite{zhu2006leap+}, Blom's Scheme \cite{blom1984optimal}, and random pairwise keys \cite{chan2003random}. In the case of random pairwise keys, path key establishment has to be implemented in addition to \gls{apkes}.


% Nevne at LEAP er best/mest snill mot strøm og minne?


During the key establishment, a responding node goes from not a neighbour, to a tentative neighbour, before ending up as a permanent neighbour, giving that the key establishment was successful. The change of neighbour status is implemented to prevent \gls{dos} attacks on nodes by flooding them with \texttt{HELLO} messages, which would force them to reply with \texttt{HELLOACK}s, potentially drain their battery. Also, injecting and replaying \texttt{HELLOACK}s and \texttt{ACK}s would also aid an attacker in draining the network's nodes for battery. Upon receiving a \texttt{HELLO} message, $V$ checks if $U$ is already a neighbour, and that it has available space in its list of tentative neighbours, which is limited to $M_t$ neighbours. 

By limiting the number of tentative neighbours, $V$ is protected against consecutive \texttt{HELLO} messages, which are discarded without being processed when the number of tentative neighbours exceed $M_t$. The list of tentative neighbours is processed for each \texttt{HELLO}, where neighbours whose expiration time has exceeded are deleted. Permanent neighbours are potentially created upon receiving valid, non-replayed \texttt{HELLOACK}s and valid \texttt{ACK}s from non-permanent neighbours. 


%\subsection{Easy Broadcast Encryption and Authentication Protocol}

%Authentication of multicast frames, however, which are sent from one node to many others and used for node discovering and network changes, are not authenticated by \gls{apkes}. Broadcast frames are authenticated with keys that are shared between neighbours, meaning that an attacker that compromises a node would not only gain access to its broadcast key, but also its neighbours' broadcast keys. As a solution for authenticating broadcast keys to achieve compromise-resilience, Krentz, Rafiee, and Meinel has suggested \gls{ebeap} to go along with \gls{apkes}. 


\subsection{Protocol specification}

Key establishment in \gls{apkes} consists of a three-way handshake, as described in Figure \ref{fig:apkes-handshake}. When a node $U$ in a \gls{6lowpan} network running gls{apkes} wants to establish contact with other nodes, it broadcasts an unauthenticated \texttt{HELLO} message containing a random nonce $Ru$. Upon receiving a \texttt{HELLO}, $V$ computes a random nonce, $Ru$, as well, and stores the concatenation of the two. $V$ then waits for a random time $T_w$. The waiting period is introduced to avoid flooding $U$ with responses, as there may be an unknown number of nodes that received the broadcast message. After $T_w$, $V$ loads its key $K_{v,u}$ from the pluggable key scheme, and uses this key to authenticate a \texttt{HELLOACK} message containing the computed $R_v$ nonce and the received $R_u$. \gls{mic}s are generated by the 802.15.4 security sublayer, through the use of \gls{ccm}*, which is a modified version of the regular \gls{ccm} allowing for the payload of the frame to be encrypted using \gls{aes} with a 128-bit key \cite{krentz20136lowpan}. \gls{apkes} uses $K_{v,u}$ to authenticate the \texttt{HELLOACK}, and sends it to $U$. Afterwards, $V$ obtains the pairwise key $K'_{v,u}$ for future communication with $U$, by plugging $K_{v,u}$ it into the \gls{aes} algorithm along with the two nonces.

% Hvorfor sjekke at Ru er den samme? Vil ikke det være åpenbart hvis MICen ikke skulle være lik?

When $U$ receives a \texttt{HELLOACK} message, it verifies the attached \gls{mic} by extracting its key $K_{u,v}$ from the pluggable scheme and computing the \gls{mic} for the concatenation of $R_u$ and $R_v$. $U$ then computes the pairwise key for communicating with $V$ by plugging it into \gls{aes} algorithm. $U$ also checks that the $R_u$ value has not been tampered with, and is equal to the value it initially sent in its \texttt{HELLO} broadcast. The three-way handshake is ends with $U$ sending an \texttt{ACK} to $V$ that is authenticated using $K'_{u,v}$. When $V$ receives the \texttt{ACK}, it verifies the \gls{mic} by using its pairwise key $K'_{v,u}$. After this process, $U$ and $V$ have agreed upon a shared pairwise key where $K'_{u,v} = K'_{v,u}$.

%In addition to the messages \texttt{HELLO} and \texttt{HELLOACK}, the frames also contains the short addresses for the sending party. These are used

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in APKES]
\begin{align*}
U:\ & Generate\ R_u\ randomly\\
U \rightarrow *:\ & \texttt{HELLO}\langle{R_u}\rangle{}\\
V:\ & Generate\ R_v\ randomly.\ Wait\ for\ T_w \leq M_w\\
V:\ & K_{v,u}\ from\ pluggable\ scheme\\
V \rightarrow U:\ & \texttt{HELLOACK}\langle{R_u, R_v}\rangle{K_{v,u}}\\
V:\ & K'_{v,u}\ =\ AES(K_{v,u}, R_u || R_v)\\
U:\ & K_{u,v}\ from\ pluggable\ scheme\\
U:\ & K'_{u,v}\ =\ AES(K_{u,v}, R_u || R_v)\\
U \rightarrow V:\ & \texttt{ACK}\langle{}\rangle{K'_{u,v}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during \gls{apkes}' three-way handshake. $\langle{msg}\rangle{K}$ indicates that the frame is authenticated using the key $K$.}
\label{fig:apkes-handshake}
\end{figure}










\section{Formal Security Analysis of APKES using Scyther}


\subsection{Key establishment}

\subsection{Key agreement}

\subsection{Security properties}

\subsubsection{Authentication}

Key authentication = Secrecy of keys

Entity authentication = aliveness


implicit authentication -> Do not know whether or not the other party possesses the session key (yet). Explicit --> got a MAC signed using the session key


HELLOACK: Implicit key authentication
ACK: Explicit key authentication ????

\subsubsection{Key Compromise Impersonation}

Impossible to achieve in protocols relying on symmetric keys? Need asymmetric? Boyd book.

\subsubsection{Unknown Key Share}

Identity of the parties as input to the KDF. 

\subsubsection{key confirmation}

non-injective synch / non-injective agreement

\subsubsection{Forward Secrecy}

Not able to achieve in symmetric key?


\subsection{Adversary Model}

\subsubsection{Specifying security properties}

\subsection{Results}

\subsection{Recommendations}




%leap master key = "ephemeral key"


%
%\begin{figure}
%	\centering
%	\includegraphics[scale=0.55]{apkes.png}
%	\caption{\gls{apkes} consists of a three-way handshake, and utilizes a pluggable scheme for deriving the shared secret between two nodes \cite{krentz20136lowpan}. $\langle{msg}\rangle{K}$ indicates that the frame is authenticated using the key $K$.}
%	\label{fig:apkes}
%\end{figure}



%\chapter{TBA}

%\chapter{Conclusion}


%\chapter{Appendix}