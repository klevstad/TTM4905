\chapter{Adaptable Pairwise Key Establishment Scheme (APKES)}
\label{chp:krentz-6lowpan}


\gls{apkes} is a proposed protocol for handling key establishment and key management in \gls{6lowpan}. It is currently implemented in the operating system Contiki, which is an operating system targeted at the sensor network community, but has not undergone any formal security analysis. This chapter will cover its ideas, and conduct a formal security analysis using Scyther. 

\section{Introduction to APKES}

As previously described, \gls{6lowpan} is a protocol stack for integrating \gls{wsn}s running on 802.15.4 with \gls{ip}v6 networks, and enables the nodes in the network to communicate with each other or remote hosts over \gls{ip}. \gls{apkes} provides a framework for establishing pairwise keys for nodes in \gls{6lowpan} networks. The advantage with pairwise keys over other key schemes such as a network-shared key is related to node compromises. In \gls{6lowpan} networks, devices are often placed in potential hostile and unattended areas, greatly increasing the possibility of being tampered with by attackers. In the case of a network shared key, the whole network would be compromised in the event of a node compromise. Also, the attacker would be able to add new nodes to the network, as the upper-layer protocols rely on the 802.15.4 security sub-layer which is able to filter out replayed packets and prevent injection, but not discover node compromises \cite{krentz20136lowpan}. A solution to the tampering problem could be to construct tampering-proof nodes, but this is expensive and difficult, hence not a preferable solution \cite{anderson1996tamper}. Pairwise keys, however, would only compromise the communication going to or from that particular node, and the establishment of such keys in the main focus of \gls{apkes}. Figure \ref{fig:6lowpan-krentz} illustrates how \gls{apkes} is implemented at the link layer along with the 820.15.4 security sublayer.

\begin{figure}
	\centering
	\includegraphics[scale=0.80]{6lowpan-krentz.png}
	\caption{\gls{apkes} is positioned in the data link layer in the \gls{6lowpan} stack expanding the 802.15.4 security sublayer \cite{krentz20136lowpan}.}
	\label{fig:6lowpan-krentz}
\end{figure}

\gls{apkes} provides a ``pluggable'' key establishment scheme for \gls{6lowpan} networks using pairwise keys, where the developer of a \gls{6lowpan} network picks an appropriate key establishment scheme and delegates \gls{apkes} into handling the key establishment with other nodes \cite{krentz20136lowpan}. As there is really no superior scheme for \gls{6lowpan} networks, the use of pluggable schemes enhances the overall usability of the protocol, as the developer can use the most appropriate scheme based on the challenges he faces. The only function of the plugged-in scheme is to feed \gls{apkes} with the shared secret for communicating nodes, and \gls{apkes} will handle both key establishment and key management. Examples of pluggable schemes that has been suggested for \gls{apkes} are \gls{leap} \cite{zhu2006leap+}, Blom's Scheme \cite{blom1984optimal}, and random pairwise keys \cite{chan2003random}. In the case of random pairwise keys, path key establishment has to be implemented in addition to \gls{apkes}.


% Nevne at LEAP er best/mest snill mot strøm og minne?


During key establishment, a responding node goes from not a neighbour, to a tentative neighbour, before ending up as a permanent neighbour, giving that the key establishment was successful. The change of neighbour status is implemented to prevent \gls{dos} attacks on nodes by flooding them with \texttt{HELLO} messages, which would force them to reply with \texttt{HELLOACK}s, potentially drain their battery. Also, injecting and replaying \texttt{HELLOACK}s and \texttt{ACK}s would also aid an attacker in draining the network's nodes for battery. Upon receiving a \texttt{HELLO} message, $V$ checks if $U$ is already a neighbour, and that it has available space in its list of tentative neighbours, which is limited to $M_t$ neighbours. 

By limiting the number of tentative neighbours, $V$ is protected against consecutive \texttt{HELLO} messages, which are discarded without being processed when the number of tentative neighbours exceed $M_t$. The list of tentative neighbours is processed for each \texttt{HELLO}, where neighbours whose expiration time has exceeded are deleted. Permanent neighbours are potentially created upon receiving valid, non-replayed \texttt{HELLOACK}s and valid \texttt{ACK}s from non-permanent neighbours. 


%\subsection{Easy Broadcast Encryption and Authentication Protocol}

%Authentication of multicast frames, however, which are sent from one node to many others and used for node discovering and network changes, are not authenticated by \gls{apkes}. Broadcast frames are authenticated with keys that are shared between neighbours, meaning that an attacker that compromises a node would not only gain access to its broadcast key, but also its neighbours' broadcast keys. As a solution for authenticating broadcast keys to achieve compromise-resilience, Krentz, Rafiee, and Meinel has suggested \gls{ebeap} to go along with \gls{apkes}. 


\subsection{Protocol specification}

Key establishment in \gls{apkes} consists of a three-way handshake, as described in Figure \ref{fig:apkes-handshake}. When a node $U$ in a \gls{6lowpan} network running gls{apkes} wants to establish contact with other nodes, it broadcasts an unauthenticated \texttt{HELLO} message containing a random nonce $Ru$. Upon receiving a \texttt{HELLO}, $V$ computes a random nonce, $Ru$, as well, and stores the concatenation of the two. $V$ then waits for a random time $T_w$. The waiting period is introduced to avoid flooding $U$ with responses, as there may be an unknown number of nodes that received the broadcasted \texttt{HELLO} message. After $T_w$, $V$ loads its key $K_{v,u}$ from the pluggable key scheme, and uses this key to authenticate a \texttt{HELLOACK} message containing the computed $R_v$ nonce and the received $R_u$. \gls{mic}s are generated by the 802.15.4 security sublayer, through the use of \gls{ccm}*, which is a modified version of the regular \gls{ccm} allowing for the payload of the frame to be encrypted using \gls{aes} with a 128-bit key \cite{krentz20136lowpan}. \gls{apkes} uses $K_{v,u}$ to authenticate the \texttt{HELLOACK}, and sends it to $U$. Afterwards, $V$ obtains the pairwise key $K'_{v,u}$ for future communication with $U$, by plugging $K_{v,u}$ it into the \gls{aes} algorithm along with the two nonces.

% Hvorfor sjekke at Ru er den samme? Vil ikke det være åpenbart hvis MICen ikke skulle være lik?

When $U$ receives a \texttt{HELLOACK} message, it verifies the attached \gls{mic} by extracting its key $K_{u,v}$ from the pluggable scheme and computing the \gls{mic} for the concatenation of $R_u$ and $R_v$. $U$ then computes the pairwise key for communicating with $V$ by plugging it into \gls{aes} algorithm. $U$ also checks that the $R_u$ value has not been tampered with, and is equal to the value it initially sent in its \texttt{HELLO} broadcast. The three-way handshake is ends with $U$ sending an \texttt{ACK} to $V$ that is authenticated using $K'_{u,v}$. When $V$ receives the \texttt{ACK}, it verifies the \gls{mic} by using its pairwise key $K'_{v,u}$. After this process, $U$ and $V$ have agreed upon a shared pairwise key where $K'_{u,v} = K'_{v,u}$.



%In addition to the messages \texttt{HELLO} and \texttt{HELLOACK}, the frames also contains the short addresses for the sending party. These are used

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in APKES]
\begin{align*}
U:\ & Generate\ R_u\ randomly\\
U \rightarrow *:\ & \texttt{HELLO}\langle{R_u}\rangle{}\\
V:\ & Generate\ R_v\ randomly.\ Wait\ for\ T_w \leq M_w\\
V:\ & K_{v,u}\ from\ pluggable\ scheme\\
V \rightarrow U:\ & \texttt{HELLOACK}\langle{R_u, R_v}\rangle{K_{v,u}}\\
V:\ & K'_{v,u}\ =\ AES(K_{v,u}, R_u || R_v)\\
U:\ & K_{u,v}\ from\ pluggable\ scheme\\
U:\ & K'_{u,v}\ =\ AES(K_{u,v}, R_u || R_v)\\
U \rightarrow V:\ & \texttt{ACK}\langle{}\rangle{K'_{u,v}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during \gls{apkes}' three-way handshake. $\langle{msg}\rangle{K}$ indicates that the frame is authenticated using the key $K$.}
\label{fig:apkes-handshake}
\end{figure}

\newpage

\section{Claimed Security Properties}

One of the focuses of \gls{apkes} is to provide authentication of parties during the key establishment process. By inspecting the messages that are exchanged between the two parties in Figure \ref{fig:apkes-handshake}, we observe that no encryption is involved in the handshake, but messages are authenticated by the use of \gls{mic}s. These \gls{mic}s are either computed using $K_{u,v}$ (the pre-shared secret) or $K'_{u,v}$ (the established pairwise key). As mentioned in Section \ref{sec:attributes}, \emph{implicit} and \emph{explicit} key authentication are two of the attributes within authentication. For a three-way handshake such as the one used by \gls{apkes}, the initiator achieves \emph{implicit} key authentication, while the responder ($V$) achieves \emph{explicit} key authentication. As the pairwise key is computed from the two nonces that are shared between $U$ and $V$, and the secret from the pluggable scheme (which we assume is secure), both know that the only parties that can compute the pairwise key is those possessing the pre-shared secret, giving them both implicit key authentication. 

$V$ also receives an \texttt{ACK} which is authenticated using the pairwise key $K'_{u,v}$, effectively meaning that $U$ has computed the pairwise key, and which $V$ can confirm by checking the attached \gls{mic}, hence it achieves explicit key authentication. From $U$'s point of view, however, it has no confirmation of that $V$ has in fact computed the pairwise key, other than it knows it is supposed to (and has to in order to verify the authenticity of the \texttt{ACK}.

Another trivial goal of key establishment is for the established key to be secret and hidden from the adversary. This is a ......?



%Authentication and encryption of unicast frames. Given that the protocol contains an authenticated three-way handshake: Explicit and implicit key authentication?

%Authentication and encryption of broadcast frames (EBEAP) Not modelled in Scyther.

\subsection{Security properties}

\subsubsection{Authentication}

Key authentication = Secrecy of keys

Entity authentication = aliveness


\section{Formal Security Analysis of APKES using Scyther}

The \gls{apkes} protocol has been implemented using Scyther, and can be viewed in its entirety in Appendix \ref{app:apkes}. The protocol is modelled as two roles, $U$ and $V$, agreeing upon a pairwise key through the message exchange that is presented in Figure \ref{fig:apkes-handshake}. There is not specified any specific type of pluggable scheme (i.e. the scheme where \gls{apkes} obtains the shared secret between two nodes), hence we assume that whatever scheme is used is secure. In the model, the shared secret between two nodes has modelled using Scyther's built-in support for shared symmetric keys.


\begin{lstlisting}[caption={Security claims for role U in APKES.}, label={lst:claims-u-apkes}]
		claim_U1(U, Alive);
		claim_U2(U, Weakagree);
		claim_U3(U, Niagree);
		claim_U4(U, Nisynch);
		claim_U5(U, Commit, V, Ru);
		claim_U6(U, Secret, PairwiseKey);
\end{lstlisting}

\begin{lstlisting}[caption={Security claims for role V in APKES.}, label={lst:claims-v-apkes}]
		claim_V1(V, Alive);
		claim_V2(V, Weakagree);
		claim_V3(V, Niagree);
		claim_V4(V, Nisynch);
		claim_V5(V, Secret, PairwiseKey);
\end{lstlisting}


\subsection{Adversary}

No specific adversary is mentioned in the description of \gls{apkes}. 



\subsection{Results}

\subsection{Recommendations}



\subsection{Limitations / Not covered by Scyther}


\gls{apkes} has support for avoiding replay attacks through the use of frame counters. Replay attacks, or \emph{injectivity} is impossible to model in Scyther, hence the formal security analysis has not covered this class of possible attacks on the protocol. 

When using pluggable scheme. Have to store key. Apkes + leap: Delete masterkey after establishing pairwise keys with all nodes. What happens if a node goes down, replaced, and rebooted? No masterkey to use. Can't establish keys with that node. hmm. Fuck this.

% How to check for properties:

% Forward Secrecy: Not able to achieve in symmetric key. Check through Scyther rules.

% Known-Key Security: Session-Key reveal

% Key Confirmation: running, commit / niagree

% Key Compromise Impersonation: Impossible to achieve in protocols relying on symmetric keys? Need asymmetric? Boyd book. SKR claim of an entity whose long-term key is revealed to the adversary

% Unknown key share: Known-Key Security?

% Entity authentication: From A to B: Aliveness of A in B's claims.

% Implicit: Long-term reveal for other entities than A and B.

% Explicit. 


% Please add the following required packages to your document preamble:
% \usepackage{multirow}
%\begin{table}[]
%\centering
%\begin{tabular}{llllllllll}
%\multicolumn{1}{c}{\multirow{2}{*}{Protocol}} & \multicolumn{2}{l}{Entity authentication} & \multirow{2}{*}{Implicit key authentication} & \multicolumn{2}{l}{Key confirmation - Explicit key authentication} & KCI resilience & Forward secrecy & Known-key security & Secrecy of key \\
%\multicolumn{1}{c}{} & Of A & Of B &  & Of A & Of B &  &  &  &  \\
%APKES & X & X & x &  &  &  &  &  &  \\
%AKES & X & X & x &  &  &  &  &  &  \\
%SAKES & X & X & x &  &  &  &  &  & 
%\end{tabular}
%\caption{My caption}
%\label{my-label}
%\end{table}
%
%
%\begin{table}[h]
%\centering
%\begin{tabular}{|p{1.3cm}|p{3cm}p{3cm}|p{3cm}|ll|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
%\hline
%Protocol & \multicolumn{2}{c}{Entity authentication} & Implicit key authentication & \multicolumn{2}{c}{Explicit key authentication} & KCI & PFS & Known-key secrecy & Secrecy of key\\ 
%- & Of A & Of B & - & Of A& Of B & -& - &- & . \\ \hline
%
%\end{tabular}
%\caption{Relationship between security properties and the adversary models in Scyther \cite{basin2010modeling}.}
%\label{tab:sec-prop-adv-mod}
%\end{table}


\begin{table}
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{lc|ccc|ccccc}
\multicolumn{1}{p{1.3cm}}{Protocol} & \multicolumn{2}{p{2.2cm}}{Entity\newline authentication} & \multicolumn{1}{p{2.2cm}}{Implicit key\newline authentication} & \multicolumn{2}{p{2.2cm}}{Explicit key\newline authentication}
& \multicolumn{1}{p{2.6cm}}{Key compromise impersonation} & \multicolumn{1}{p{1.1cm}}{Forward\newline Secrecy} & \multicolumn{1}{p{1.75cm}}{Known-key\newline security} & \multicolumn{1}{p{1.0cm}}{Secrecy\newline of key}\\
 & Of A & Of B &  & Of A & Of B &  &  & &\\ \hline
 APKES & \checkmark & x & x & x & x & x & x & x & x\\
\end{tabular}}
\end{table}
