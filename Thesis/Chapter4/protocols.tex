\chapter{Three Protocols for Key Establishment in 6LoWPAN}
\label{chp:protocols}


\section{Adaptable Pairwise Key Establishment Scheme (APKES)}


\gls{apkes} is a proposed protocol by Krentz et al. for handling key establishment and key management in \gls{6lowpan} \cite{krentz20136lowpan}. It is currently implemented in the operating system Contiki, which is targeted at the sensor network community. As previously described, \gls{6lowpan} is a protocol stack for integrating \gls{wsn}s running on 802.15.4 with \gls{ip}v6 networks, and enables the nodes in the network to communicate with each other or remote hosts over \gls{ip}. \gls{apkes} provides a framework for establishing pairwise keys for nodes in \gls{6lowpan} networks. The advantage with pairwise keys over other key schemes such as a network-shared key is related to node compromises. In \gls{6lowpan} networks, devices are often placed in potential hostile and unattended areas, greatly increasing the possibility of being tampered with by attackers.

In the case of a network shared key, the whole network would be compromised in the event of a node compromise. Also, the attacker would be able to add new nodes to the network, as the upper-layer protocols rely on the 802.15.4 security sub-layer which is able to filter out replayed packets and prevent injection, but not discover node compromises \cite{krentz20136lowpan}. A solution to the tampering problem could be to construct tampering-proof nodes, but this is expensive and difficult, hence not a preferable solution \cite{anderson1996tamper}. Pairwise keys, however, would only compromise the communication going to or from that particular node, and the establishment of such keys is the main focus of \gls{apkes}.

Figure \ref{fig:6lowpan-krentz} illustrates how \gls{apkes} is implemented at the link layer along with the 820.15.4 security sublayer. In its implementation, \gls{apkes} introduces three special messages which are used in the key establishment process, namely \texttt{HELLO}, \texttt{HELLOACK}, and \texttt{ACK} \cite{krentz20136lowpan}. These are defined as 802.15.4 command messages, which are only processed by the data link layer (i.e they are not passed to upper layers), hence \gls{apkes} is able to establish pairwise keys for networks building on 802.15.4 independently from the protocols running in the upper layers.

\begin{figure}
	\centering
	\includegraphics[scale=0.80]{6lowpan-krentz.png}
	\caption{APKES is positioned in the data link layer in the 6LoWPAN stack expanding the 802.15.4 security sublayer \cite{krentz20136lowpan}.}
	\label{fig:6lowpan-krentz}
\end{figure}

\gls{apkes} provides a ``pluggable'' key establishment scheme for \gls{6lowpan} networks using pairwise keys, where the developer of a \gls{6lowpan} network picks an appropriate key establishment scheme and delegates \gls{apkes} into handling the key establishment with other nodes \cite{krentz20136lowpan}. As there is really no superior scheme for \gls{6lowpan} networks, the use of pluggable schemes enhances the overall usability of the protocol, as the developer can use the most appropriate scheme based on the challenges he faces. The only function of the plugged-in scheme is to feed \gls{apkes} with the shared secret for the communicating nodes, and \gls{apkes} will handle both key establishment and key management. Examples of pluggable schemes that have been suggested for \gls{apkes} are \gls{leap} \cite{zhu2006leap+}, Blom's Scheme \cite{blom1984optimal}, and random pairwise keys \cite{chan2003random}. In the case of random pairwise keys, path key establishment has to be implemented in addition to \gls{apkes}.

During the key establishment process, a responding node goes from not being a neighbour, to a tentative neighbour, before ending up as a permanent neighbour, given that the key establishment was successfully executed. The change of neighbour status is implemented to prevent \gls{dos} attacks on nodes by flooding them with messages for starting key establishments (\texttt{HELLO} messages), which would force them to reply to each message (denoted as \texttt{HELLOACK}), potentially drain their battery. Also, injecting and replaying these replies could also aid an attacker in draining the network's nodes for battery. Upon receiving a \texttt{HELLO} message, the responder ($B$) checks if the initiator ($A$) is already a neighbour, and that it has available space in its list of tentative neighbours, which is limited to $M_t$ neighbours. 

\gls{apkes} modifies the security sub-layer of 802.15.4 to instantly discard data frames that arrives from non-permanent neighbours, only accepting \texttt{HELLO}s, \texttt{HELLOACK}s, or \texttt{ACK}s. By limiting the number of tentative neighbours, $B$ is protected against consecutive \texttt{HELLO} messages, which are discarded without being processed when the number of tentative neighbours exceeds $M_t$. The list of tentative neighbours is processed for each \texttt{HELLO}, where neighbours whose expiration time has expired are deleted. The status change from tentative to permanent neighbour is potentially done upon receiving a valid, non-replayed \texttt{HELLOACK} or \texttt{ACK} from a non-permanent neighbour.

%\subsection{Easy Broadcast Encryption and Authentication Protocol}

%Authentication of multicast frames, however, which are sent from one node to many others and used for node discovering and network changes, are not authenticated by \gls{apkes}. Broadcast frames are authenticated with keys that are shared between neighbours, meaning that an attacker that compromises a node would not only gain access to its broadcast key, but also its neighbours' broadcast keys. As a solution for authenticating broadcast keys to achieve compromise-resilience, Krentz, Rafiee, and Meinel has suggested \gls{ebeap} to go along with \gls{apkes}. 


\subsection{Protocol specification}
\label{subsec:apkes-spec}

Key establishment in \gls{apkes} consists of a three-way handshake, as described in Figure \ref{fig:apkes-handshake}. When a node $A$ in a \gls{6lowpan} network running \gls{apkes} wants to establish contact with other nodes, it broadcasts an unauthenticated \texttt{HELLO} message containing a random nonce $Ra$. Upon receiving a \texttt{HELLO}, $B$ computes a random nonce, $Ra$, as well, and stores the concatenation of the two. $B$ then waits for a random time $T_w$. The waiting period is introduced to avoid flooding $A$ with responses, as there may be an unknown number of nodes that received the broadcasted \texttt{HELLO} message. After $T_w$, $B$ loads its key $K_{B,A}$ from the pluggable key scheme, and uses this key to authenticate a \texttt{HELLOACK} message containing the computed $R_B$ nonce and the received $R_A$. \gls{mic}s are generated by the 802.15.4 security sublayer, through the use of \gls{ccm}*, which is a modified version of the regular \gls{ccm} allowing for the payload of the frame to be encrypted using \gls{aes} with a 128-bit key \cite{krentz20136lowpan}. \gls{apkes} uses $K_{B,A}$ to authenticate the \texttt{HELLOACK}, and sends it to $A$. Afterwards, $B$ obtains the pairwise key $K'_{B,A}$ for future communication with $A$, by plugging $K_{B,A}$ it into the \gls{aes} algorithm along with the two nonces.

% Hvorfor sjekke at Ra er den samme? Vil ikke det være åpenbart hvis MICen ikke skulle være lik?

When $A$ receives a \texttt{HELLOACK} message, it verifies the attached \gls{mic} by extracting its key $K_{A,B}$ from the pluggable scheme and computing the \gls{mic} for the concatenation of $R_A$ and $R_B$. $A$ then computes the pairwise key for communicating with $B$ by plugging it into the \gls{aes} algorithm. $A$ also checks that the $R_A$ value has not been tampered with, and is equal to the value it initially sent in its \texttt{HELLO} broadcast. The three-way handshake ends with $A$ sending an \texttt{ACK} to $B$ that is authenticated using the pairwise key $K'_{A,B}$. When $B$ receives the \texttt{ACK}, it verifies the \gls{mic} by using its derived pairwise key $K'_{B,A}$. After this process, $A$ and $B$ have successfully agreed upon a shared pairwise key where $K'_{A,B} = K'_{B,A}$, which is to be used for encrypting all future communication between the two nodes.



%In addition to the messages \texttt{HELLO} and \texttt{HELLOACK}, the frames also contains the short addresses for the sending party. These are used

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in APKES]
\begin{align*}
A:\ & Generate\ R_A\ randomly\\
A \rightarrow *:\ & \texttt{HELLO}\langle{R_A}\rangle{}\\
B:\ & Generate\ R_B\ randomly.\ Wait\ for\ T_w \leq M_w\\
B:\ & K_{B,A}\ from\ pluggable\ scheme\\
B \rightarrow A:\ & \texttt{HELLOACK}\langle{R_A, R_B}\rangle{K_{B,A}}\\
B:\ & K'_{B,A}\ =\ AES(K_{B,A}, R_A || R_B)\\
A:\ & K_{A,B}\ from\ pluggable\ scheme\\
A:\ & K'_{A,B}\ =\ AES(K_{A,B}, R_A || R_B)\\
A \rightarrow B:\ & \texttt{ACK}\langle{}\rangle{K'_{A,B}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during APKES' three-way handshake.}
\label{fig:apkes-handshake}
\end{figure}

\subsection{Assumptions of Security Properties}
\label{subsec:apkes-prop}

One of the focuses of \gls{apkes} is to provide authentication of parties during the key establishment process. By inspecting the messages that are exchanged between the two parties in Figure \ref{fig:apkes-handshake}, we observe that no encryption is involved in the handshake, but messages are authenticated by the use of \gls{mic}s. These \gls{mic}s are either computed using $K_{A,B}$ (the pre-shared secret) or $K'_{A,B}$ (the established pairwise key). Therefore, we can assume that entity authentication has to hold for the two communicating parties. Also, as mentioned in Section \ref{sec:attributes}, \emph{implicit} and \emph{explicit} key authentication are two of the other attributes within authentication. For a three-way handshake such as the one used by \gls{apkes}, the initiator achieves \emph{implicit} key authentication, while the responder ($B$) achieves \emph{explicit} key authentication. As the pairwise key is computed from the two nonces that are shared between $A$ and $B$, and the secret from the pluggable scheme (which we assume is secure), both know that the only parties that can compute the pairwise key is those possessing the pre-shared secret, giving them both implicit key authentication. 

$B$ also receives an \texttt{ACK} which is authenticated using the pairwise key $K'_{A,B}$, effectively meaning that $A$ has computed the pairwise key, and which $B$ can confirm by checking the attached \gls{mic}, hence it can be said to achieve explicit key authentication. From $A$'s point of view, however, it has no confirmation of that $B$ has in fact computed the pairwise key, other than it knows it is supposed to (and has to in order to verify the authenticity of the \texttt{ACK}. Also, as \gls{apkes} is a key establishment protocol, the established key is of course claimed to be secret from the adversary.

\subsection{Weaknesses and Challenges with APKES}
\label{subsec:apkes-weakness}

\gls{apkes} establishes a shared symmetric key between nodes, which is used to encrypt and decrypt data that is sent between them. One issue that the protocol does not address is the case where, for some reason, the node is forced to do a reboot. To avoid replay attacks, a node needs to keep control over the frame counters of the nodes it communicates with. These frame counters need to be swapped from the \gls{ram} memory of the device to a non-volatile storage over time. Such storages are for most 802.15.4 devices flash memory, making the swapping process both energy and time consuming \cite{krentz2015handling}. In the Contiki operating system (where \gls{apkes} is implemented), reboot commands are issued whenever processes get stuck or when replacing the battery of the device \cite{dunkels2004contiki}. In the case of a reboot without storing the frame counter, neighbouring nodes would simply discard all messages from the node, as the frame counter would start at zero, and the frames would be considered replayed. Another issue with storing anti-replay data is that \gls{apkes} does not remove information of disappeared neighbours (nor does it discover that a node has left the neighbourhood), which may unnecessarily seize a large part of the node's memory over time.  

In addition to the weaknesses related to frame counters and storing anti-replay protection data, \gls{apkes} has issued related to its usage of temporary and permanent neighbours. As mentioned, the life cycle of a neighbour node ranges from not being associated at all, to becoming a temporary, and finally a permanent neighbour during the key establishment process. However, \gls{apkes} discards \texttt{HELLO} messages from permanent neighbours to prevent \gls{dos} attacks. This means that if a neighbour reboots, it goes into a deadlock with previous neighbours, where it is not able to establish any new keys with these nodes as its \texttt{HELLO}s would silently be discarded. The broadcasting of \texttt{HELLO}s only occurs immediately after the node is booted up, which means that after the node is up and running, it will not attempt to connect to any new neighbours that may have been deployed afterwards. One can argue that it is the responsibility of the post-deployed nodes to establish contact with ``early birds'', but deployed nodes should nevertheless be able to discover new nodes during runtime. 

These issues can be applied into a real life scenario to better understand the limitations of the protocol. Assume a \gls{wsn} for medical applications with multiple devices attached to certain medical equipment. Networks around patient are not necessary stationary, as they may be moved to different facilities in the hospital. Also, certain medical equipment are very expensive, which would encourage reuse and reassignment of the devices (i.e. supporting mobility for these devices may be an important factor for certain cases). 



\section{Adaptable Key Establishment Scheme (AKES)}

The \gls{akes} aims to improve and fix the weaknesses that was introduced in \gls{apkes}, and is currently implemented in the Contiki operating system \cite{krentz2015handling}. Its main goal is to establish session keys between devices in a \gls{6lowpan} network, while being able to withstand reboots and movement from one network to another. As described in Section \ref{subsec:apkes-weakness}, \gls{apkes} suffered from issues when rebooting the device, and it was not able to provide any mobility. Most of these issues can be solved by one ``simple'' adjustment: Establishing session keys between nodes instead of long-term keys. By establishing session keys, \gls{mic}s from previous sessions would be invalidated, which enables node to delete data used for providing replay protection (such as frame counters), and will also filter out old frames. Also, this removes the problem related to frame counters being reset after a reboot, as mentioned in Section \ref{subsec:apkes-weakness}. 

\gls{akes} builds on the approach from \gls{apkes}, where the underlying scheme is pluggable provides \gls{akes} with the pre-shared secret between nodes. Before an 802.15.4 node is able to run \gls{akes}, addressing information (which uniquely identifies a node within an 802.15.4 network and is used by the pluggable scheme when establishing the shared secret) and keying material has to be preloaded into it. \gls{akes} also has access to the same command frames \texttt{HELLO}, \texttt{HELLOACK}, and \texttt{ACK}, which are used to establish session keys, and only processed by the data link layer. Figure \ref{fig:6lowpan-krentz} describes where \gls{apkes} is implemented in the \gls{6lowpan} stack, and as \gls{akes} is merely an improvement over \gls{apkes}, it is implemented on the same layer as the 802.15.4 Security Sublayer. 

As in \gls{apkes}, \gls{akes} also utilizes a differentiation between non-neighbours, temporary neighbours, and permanent neighbours. When a node sends a \texttt{HELLO} it will obtain a status as a temporary node at the receiver. This status will be changed to permanent upon receipt of an authentic \texttt{ACK} message as part of the final step in the session key establishment. Keep in mind that one of the issues with \gls{apkes} was the deadlock state rebooted nodes would start in with previously permanent neighbours. In \gls{akes}, permanent neighbours who transmits a \texttt{HELLO} message will obtain a status as a temporary neighbour in addition to its old permanent neighbour status, until the \texttt{ACK} is received. After receiving the \texttt{ACK}, the permanent neighbour status is deleted and the temporary is turned into a permanent one, which effectively renews the session between the two nodes. When a permanent neighbour(i.e. a session key) is established, the neighbour is assigned an expiration time where the key becomes invalid. The lime time of a session is, however, prolonged for each received, authentic frame from the particular session, and can also be prolonged by issuing certain commands. 

\gls{akes} introduces two tasks for preventing deadlocks and increasing mobility for devices, while still keeping \gls{dos} attacks in mind: Periodically pinging its permanent neighbours to delete disappeared nodes, and discover new neighbours by routinely broadcasting \texttt{HELLO}s. When a session with a neighbour expires, the node issues an authenticated \texttt{UPDATE} command and sends it to the node, which potentially responds with an \texttt{UPDATEACK}. A received \texttt{UPDATEACK} leads to both parties of the session extending the lifetime of their key, while the absence of such an acknowledgement, it will try a few times before eventually giving up and deleting the neighbour from its view of the network.

Trickle, which is an algorithm for distributing information in \gls{wsn}s \cite{levis2011trickle}, is adopted by \gls{akes} for discovering new neighbours in a routinely matter. The challenge is to define \emph{how} often the node should broadcast \texttt{HELLO}s in order to discover new nodes and changes to the network topology, which Trickle aim to solve by applying different network statistics into its algorithm.

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in AKES]
\begin{align*}
A:\ & Generate\ R_A\ randomly\\
A \rightarrow *:\ & \texttt{HELLO}\langle{PAN_A, ID_A, R_A, C_A}\rangle{}\\
B:\ & K_{B,A}\ from\ pluggable\ scheme\\
B:\ & Generate\ R_B\ randomly.\ Wait\ for\ T_w \leq M_w\\
B:\ & K'_{B,A}\ =\ AES(K_{B,A}, R_A || R_B)\\
B \rightarrow A:\ & \texttt{HELLOACK}\langle{PAN_A, ID_A, PAN_B, ID_B, R_B, I_{A,B}, C_B, P_A}\rangle{K_{B,A}}\\
A:\ & K_{A,B}\ from\ pluggable\ scheme\\
A:\ & K'_{A,B}\ =\ AES(K_{A,B}, R_A || R_B)\\
A \rightarrow B:\ & \texttt{ACK}\langle{PAN_B, ID_B, PAN_A, ID_A, I_{B,A}, C_A}\rangle{K'_{A,B}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during AKES' three-way handshake.}
\label{fig:akes-handshake}
\end{figure}

\subsection{Protocol Specification}

In \gls{akes}, the key establishment process consists of a three-way handshake where the two nodes establish a session key, as described in Figure \ref{fig:akes-handshake}. Initially, the node $A$ broadcasts a \texttt{HELLO} message to its neighbours containing a randomly generated nonce value $R_A$ along with the identity of the node, its \gls{pan} address, and the frame counter $C_A$. The \texttt{HELLO} broadcast is authenticated using \gls{ebeap} \cite{krentz20136lowpan}, which is a protocol for authenticating broadcast frames in \gls{6lowpan} networks, or a pre-distributed group session key. When $B$ receives a \texttt{HELLO} broadcast, generates a random nonce as well, denoted as $R_B$. It then proceeds to request the shared secret $K_{B,A}$ from its pluggable scheme, and uses this key to derive the pairwise session key $K'_{B,A}$ as $AES-128(K_{B,A}, R_A || R_B)$. $B$ then crafts a \texttt{HELLOACK} response which is sent to $A$ containing $R_B$. The \texttt{HELLOACK} is authenticated by adding a \gls{mic} generated with $K_{B,A}$, in addition to $B$'s \gls{pan} address, identity, and other values related to frame counters and \gls{ebeap} authentication. In the response, $B$ attaches a field $P_A$ as well to indicate whether or not $A$ is currently registered as a permanent neighbour of $B$, and is also capable of piggybacking group session keys. If the $P_A$ field is set, $A$ can choose to disconnect from the establishment, which would be normal if the \texttt{HELLO} was just a routine broadcast. Upon receiving the \texttt{HELLOACK}, $A$ validates the attached \gls{mic} by computing the pairwise session key $K'_{A, B}$ in the same manner as $B$. After this, future communication  is encrypted using the shared pairwise session key until it expires.


\subsection{Assumptions of Security Properties}






\section{Secure Authentication and Key Establishment Scheme (SAKES)}

The third, and last protocol which will be discussed in this thesis, is the \gls{sakes}. \gls{sakes} claims to provide secure authentication and key establishment for nodes in a device-to-device network running on \gls{6lowpan} \cite{hussen2013sakes}. Previous described protocols such as \gls{apkes} and \gls{akes} enables devices to directly communicate with each other without any previous authentication have taken place. The architecture in \gls{sakes} as seen in Figure \ref{fig:sakes-arch} consists of end devices, \gls{6lowpan} routers, \gls{6lowpan} border routers, and remote servers providing services to the devices. End devices are typically sensors, with very limited computational power. Border routers and ordinary \gls{6lowpan} routers are more powerful entities which are able to perform lightweight public key cryptography operations.


\begin{figure}[h]
	\centering
	\includegraphics[scale=0.60]{sakes-arch.png}
	\caption{Figure of the architecture for a 6LoWPAN network using SAKES for authentication and key establishment.}
	\label{fig:sakes-arch}
\end{figure}


Border routers, also known as ``edge routers'', are in addition responsible for handling communication between the end devices and the Internet (as well as other IP-based networks), act as a broker between local data exchanged between the end devices, and generate and maintain the \gls{6lowpan} subnet \cite{olsson20146lowpan}. In \gls{sakes}, the border router is responsible for authenticating end devices and \gls{6lowpan} routers to each other, as well as generating ephemeral public-key pairs for the router to use in session key establishment. In addition to these tasks, the border router is also responsible for periodically distribute symmetric shared keys to its registered nodes.

The use of different entities with more computational power than a regular sensor device allows \gls{sakes} to provide a key establishment scheme utilizing both pairwise symmetric keys and lightweight public key cryptography. \gls{sakes} assumes that the nodes within the network are stationary are pre-registered in the border router's authentication module, which is a trusted entity between the remote server and the \gls{6lowpan} network. While not defined any where in the specification, we assume that this includes possessing the public key of the border router. 

Before a device is able to communicate with the remote server, it needs to authenticate itself to the server, as well as confirming that the nearest \gls{6lowpan} router is a authentic and valid gateway on its way to the server. The authentication module of the border router handles the authentication process, by authenticating a request sent by the end device to the router, which relays it to the border router. This request contains the identity of the end device, the router, and the remote server. If the entities are registered in the authentication module, the border router notifies both the end device and the router with a confirmation of the other party's identity. \gls{sakes} utilizing, as mentioned, a lightweight public key approach where the border router also generates an ephemeral public key pair for the router, which is to be used for session key establishment with the remote server.

Session key establishment between the end device and remote server is done by the router acting on behalf of the end device. For establishing the key, \gls{sakes} utilizes a form of Diffie-Hell key agreement by exchanging public keys with the remote server, before distributing the session key securely to the end device.


%\gls{sakes} was suggested as a scheme for securing communication for device-to-device communication 


\subsection{Protocol Specification}

\gls{sakes} consists of two phases: Authentication and session key establishment. Figure \ref{fig:sakes-auth} describes the messages exchanged between the end device ($A$), the \gls{6lowpan} router ($B$), and the border router ($C$) in the authentication phase of \gls{sakes}. $A$ starts the authentication by generating a random nonce $N_A$, which it transmits to its closest router $B$. The router responds by generating its own random nonce $N_B$, and sends this back to $A$. The identities of the end device, the closest router of the end device, and the remote server the device wants to connect to is then encrypted into the ciphertext $C_A$ by $A$ using the symmetric key $K_{AC}$, which is shared between the end device and the border router. $A$ also then sends this ciphertext along with its identity and previously computed nonce to the router after adding a \gls{mac-auth} of the message using the shared key $K_{AB}$.

Upon receiving the request from $A$, $B$ authenticates the \gls{mac-auth} of the message by using its copy of the secret key, and adds its own nonce $N_B$ to the message. $B$ then proceeds to add a \gls{mac-auth} of the message as well, using the symmetric key $K_{BC}$, which is shared between $B$ and $C$, before relaying the request to the border router $C$. The border router checks the attached \gls{mac-auth} as well, by using its own copy of the symmetric key shared between $B$ and $C$. It then decrypts the ciphertext created by $A$ which contains the identity of the end device, the router and the remote server by using the symmetric key it shares with $A$.


\begin{figure}[h]
\begin{tcolorbox}[title=Authentication in SAKES]
\begin{align*}
A:\ & Generate\ N_A\ randomly\\
A \rightarrow B:\ & N_A\\
B:\ & Generate\ N_B\ randomly\\
B \rightarrow A:\ & N_B\\
A:\ & Construct\ C_{A}:\ \{ID_A, ID_B, ID_D\}_{K_{AC}}\\
A \rightarrow B:\ & \langle{C_A, ID_A, N_A}\rangle{K_{AB}}\\
B \rightarrow C:\ & \langle{C_A, ID_B, N_B}\rangle{K_{BC}}\\
C:\ & Verify\ the\ identity\ of\ A,\ B,\ and\ D\\
C: \ & Construct\ S_C: \{ID_A, ID_B, ID_D\}_{Sk_{C}}\\
C:\ & Generate\ N_C\ randomly\ and\ a\ public\ key\ pair\ (Pk_B, Sk_B)\\
C \rightarrow B:\ & \{N_C, S_C, Pk_B, Sk_B\}_{K_{BC}}\\
C \rightarrow A:\ & \langle{ID_B, N_C}\rangle{K_{AC}}\\
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between the end device (A), router (B), and border router (with authentication module) (C) in SAKES' authentication phase.}
\label{fig:sakes-auth}
\end{figure}

The border router then checks with its authentication module whether the message is really sent by the end device $A$, and if the identity of its nearest neighbour router $B$ is correct. If these checks are successful, the border router signs the identities of the end device, router, and remote server into the term $S_C$. It also generates a public key pair $(Pk_B, Sk_B)$ based on \gls{ecc}, and random nonce $N_D$. It then sends two messages: one to the router, and one to the end device. The message sent to $B$ contains the nonce $N_D$, the signed message $S_C$ containing the verified identities of the request, and the public key pair for $B$ to use in the key establishment phase. To provide secrecy for the generated key pair, the entire message is encrypted under the shared symmetric key $K_BC$ to ensure that the key pair is only accessible to $B$. The end device $A$ also receives a confirmation message from $C$ containing the identity of the router, as well as the random nonce $N_D$ to prevent replaying. To ensure authenticity of the message, it is authenticated using a \gls{mac-auth} with the shared secret $K_{AC}$ as the key.

After both the end device and the router receives their confirmation messages and successfully verifies their authenticity, the authentication process is believed to be completed. The next step in \gls{sakes} is for the router $B$ to establish a session key with the remote server $D$ on behalf of the end device $A$, as the end device often has limited computational power. The messages sent between the entities in the key establishment phase of \gls{sakes} can be seen in Figure \ref{fig:sakes-keys}.

\begin{figure}[h]
\begin{tcolorbox}[title=Key Establishment in SAKES]
\begin{align*}
B \rightarrow D:\ & \{C_C, N_B, Pk_B, B, hash\}_{Sk_B} \\
D:\ & Calculate\ Session\ Key\ (SK_D):\ SK_D = g^{Pk_B * Sk_D} \mod{P}\\
D:\ & Generate\ N_D\ randomly\\
D \rightarrow B:\ & \{Pk_D, P, g, N_D, hash\}_{Sk_D}\\
B:\ & Calculate\ Session\ Key\ for\ A\ (SK_A):\ SK_A = g^{Pk_D * Sk_B} \mod{P}\\
B \rightarrow A:\ & \{SK_A, N_B\}_{K_{AB}}\\
Claim:\ & SK_A = SK_D\\
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties in SAKES' key establishment between the end device (A), the 6LoWPAN router (B), and the remote server (D).}
\label{fig:sakes-keys}
\end{figure}

The router crafts a request containing the obtained signed proof from the border router, its identity and the random nonce $N_B$, and it also adds its temporary public key $Pk_B$. In addition, $B$ computes a hash of the message and appends it as well, before signing it. By signing the message using its corresponding private key $Sk_B$, $B$ allows the remote server to verify the authenticity of the message by using the attached public key $Pk_B$. The server then checks the authenticity of the signed proof in the message that the authentication module in $C$ created by applying its copy of $C$'s public key.

The computation of the session key $SK_D$ in \gls{sakes} is displayed in Equation \ref{eq:skd}, allegedly utilizing a version of the Diffie-Hellman key agreement. In the equation, $g$ and $P$ are two cryptographic numbers, respectively a generator and a prime modulus, while the exponents are the public key of the router $B$ and the private key of the server $D$. After generating the session key, $D$ constructs a message to $B$ containing its public key, a random nonce $N_D$, and the two cryptographic numbers $g$ and $P$. A hash of the message is attached as well, before it is signed using the remote server's private key $Sk_D$, and sent to $B$. 

\begin{equation}
\label{eq:skd}
SK_D = g^{\ Pk_{B}\ *\ Sk_D} \mod P
\end{equation}

Upon receiving the response from the remote server, $B$ computes the hash for the message and compares it to the attached hash value, as well as verifying that the signature matches the public key. The session key for the end device is computed as in Equation \ref{eq:ska}, using the received cryptographic numbers $g$ and $P$, and the public key of $D$ and $B$'s ephemeral private key. In order to distribute the session key securely to the end device $A$, the key is encrypted along with the nonce $N_B$ under the symmetric key $K_{AB}$, and sent to $A$. After the end device successfully decrypts and retrieves its session key, future communication between $A$ and $D$ will be encrypted using the session key. 

\begin{equation}
\label{eq:ska}
SK_A = g^{\ Pk_{D}\ *\ Sk_B} \mod P
\end{equation}


\subsection{Assumptions of Security Properties}

\gls{sakes} uses an authentication module located in the border router to authenticate end devices and routers before granting them a signed proof to use in the key establishment process. Authentication is one of the most fundamental security properties in a key establishment, and therefore it is fair to assume that \gls{sakes} should provide authentication between end devices, routers and border routers. The key establishment process is merely conducted between the router and the remote server, where the remote server has no knowledge of the end device, while the border router is absent from this phase. Therefore, we assume that authentication in this process is claimed between end device and router, and between the router and the remote server.

As \gls{sakes} makes use of both pairwise keys and public key pairs, the generated session keys should of course be claimed to be secret. Also, the private key of the ephemeral key pair generated the authentication module should be secret to ensure the secrecy of the generated session key. In modern key establishment schemes, the Diffie-Hellman key agreement process can be used to provide forward secrecy for communicating parties. In \gls{sakes}, only the remote server holds a long-term public key pair, while the border router generates a fresh ephemeral key pair for each session. Nevertheless, forward secrecy should be a desirable property for protocols that leverage Diffie-Hellmen. 


\subsection{Weaknesses}

The major downside with the proposed \gls{sakes} protocol is that the authors have misunderstood the concept of Diffie-Hellman key agreement. If we look closer on the two equations that derives the alleged identical session keys, we observe that they are in fact unequal. The mathematical equation for Diffie Hellman is listed in Equation \ref{eq:dh} below.

\begin{equation}
\label{eq:dh}
(g^a \mod p)^b \mod p = (g^b \mod p)^a \mod p
\end{equation}

In \gls{sakes} the private key of the remote server and the ephemeral public key of the router is used to calculate the session key at the server's side. However, the router uses its own ephemeral private key and the public key of server to compute the session key, which basically means something like Equation \ref{eq:dh-wrong}.

\begin{equation}
\label{eq:dh-wrong}
(g^a \mod p)^b \mod p \neq (g^c \mod p)^d \mod p
\end{equation}

% How to check for properties:

% Forward Secrecy: Not able to achieve in symmetric key. Check through Scyther rules.

% Known-Key Security: Session-Key reveal

% Key Confirmation: running, commit / niagree

% Key Compromise Impersonation: Impossible to achieve in protocols relying on symmetric keys? Need asymmetric? Boyd book. SKR claim of an entity whose long-term key is revealed to the adversary

% Unknown key share: Known-Key Security?

% Entity authentication: From A to B: Aliveness of A in B's claims.

% Implicit: Long-term reveal for other entities than A and B.

% Explicit. Implicit + key confirmation
