\chapter{Three Protocols for Key Establishment in 6LoWPAN}
\label{chp:protocols}


\section{Adaptable Pairwise Key Establishment Scheme (APKES)}


\gls{apkes} is a proposed protocol by Krentz et al. for handling key establishment and key management in \gls{6lowpan} \cite{krentz20136lowpan}. It is currently implemented in the operating system Contiki, which is targeted at the sensor network community. As previously described, \gls{6lowpan} is a protocol stack for integrating \gls{wsn}s running on 802.15.4 with \gls{ip}v6 networks, and enables the nodes in the network to communicate with each other or remote hosts over \gls{ip}. \gls{apkes} provides a framework for establishing pairwise keys for nodes in \gls{6lowpan} networks. The advantage with pairwise keys over other key schemes such as a network-shared key is related to node compromises. In \gls{6lowpan} networks, devices are often placed in potential hostile and unattended areas, greatly increasing the possibility of being tampered with by attackers.

In the case of a network shared key, the whole network would be compromised in the event of a node compromise. Also, the attacker would be able to add new nodes to the network, as the upper-layer protocols rely on the 802.15.4 security sub-layer which is able to filter out replayed packets and prevent injection, but not discover node compromises \cite{krentz20136lowpan}. A solution to the tampering problem could be to construct tampering-proof nodes, but this is expensive and difficult, hence not a preferable solution \cite{anderson1996tamper}. Pairwise keys, however, would only compromise the communication going to or from that particular node, and the establishment of such keys is the main focus of \gls{apkes}.

Figure \ref{fig:6lowpan-krentz} illustrates how \gls{apkes} is implemented at the link layer along with the 820.15.4 security sublayer. In its implementation, \gls{apkes} introduces three special messages which are used in the key establishment process, namely \texttt{HELLO}, \texttt{HELLOACK}, and \texttt{ACK} \cite{krentz20136lowpan}. These are defined as 802.15.4 command messages, which are only processed by the data link layer (i.e they are not passed to upper layers), hence \gls{apkes} is able to establish pairwise keys for networks building on 802.15.4 independently from the protocols running in the upper layers.

\begin{figure}
	\centering
	\includegraphics[scale=0.80]{6lowpan-krentz.png}
	\caption{APKES is positioned in the data link layer in the 6LoWPAN stack expanding the 802.15.4 security sublayer \cite{krentz20136lowpan}.}
	\label{fig:6lowpan-krentz}
\end{figure}

\gls{apkes} provides a ``pluggable'' key establishment scheme for \gls{6lowpan} networks using pairwise keys, where the developer of a \gls{6lowpan} network picks an appropriate key establishment scheme and delegates \gls{apkes} into handling the key establishment with other nodes \cite{krentz20136lowpan}. As there is really no superior scheme for \gls{6lowpan} networks, the use of pluggable schemes enhances the overall usability of the protocol, as the developer can use the most appropriate scheme based on the challenges he faces. The only function of the plugged-in scheme is to feed \gls{apkes} with the shared secret for the communicating nodes, and \gls{apkes} will handle both key establishment and key management. Examples of pluggable schemes that have been suggested for \gls{apkes} are \gls{leap} \cite{zhu2006leap+}, Blom's Scheme \cite{blom1984optimal}, and random pairwise keys \cite{chan2003random}. In the case of random pairwise keys, path key establishment has to be implemented in addition to \gls{apkes}.

During the key establishment process, a responding node goes from not being a neighbour, to a tentative neighbour, before ending up as a permanent neighbour, given that the key establishment was successfully executed. The change of neighbour status is implemented to prevent \gls{dos} attacks on nodes by flooding them with messages for starting key establishments (\texttt{HELLO} messages), which would force them to reply to each message (denoted as \texttt{HELLOACK}), potentially drain their battery. Also, injecting and replaying these replies could also aid an attacker in draining the network's nodes for battery. Upon receiving a \texttt{HELLO} message, the responder ($B$) checks if the initiator ($A$) is already a neighbour, and that it has available space in its list of tentative neighbours, which is limited to $M_t$ neighbours. 

\gls{apkes} modifies the security sub-layer of 802.15.4 to instantly discard data frames that arrives from non-permanent neighbours, only accepting \texttt{HELLO}s, \texttt{HELLOACK}s, or \texttt{ACK}s. By limiting the number of tentative neighbours, $B$ is protected against consecutive \texttt{HELLO} messages, which are discarded without being processed when the number of tentative neighbours exceeds $M_t$. The list of tentative neighbours is processed for each \texttt{HELLO}, where neighbours whose expiration time has expired are deleted. The status change from tentative to permanent neighbour is potentially done upon receiving a valid, non-replayed \texttt{HELLOACK} or \texttt{ACK} from a non-permanent neighbour.

%\subsection{Easy Broadcast Encryption and Authentication Protocol}

%Authentication of multicast frames, however, which are sent from one node to many others and used for node discovering and network changes, are not authenticated by \gls{apkes}. Broadcast frames are authenticated with keys that are shared between neighbours, meaning that an attacker that compromises a node would not only gain access to its broadcast key, but also its neighbours' broadcast keys. As a solution for authenticating broadcast keys to achieve compromise-resilience, Krentz, Rafiee, and Meinel has suggested \gls{ebeap} to go along with \gls{apkes}. 


\subsection{Protocol specification}
\label{subsec:apkes-spec}

Key establishment in \gls{apkes} consists of a three-way handshake, as described in Figure \ref{fig:apkes-handshake}. When a node $A$ in a \gls{6lowpan} network running \gls{apkes} wants to establish contact with other nodes, it broadcasts an unauthenticated \texttt{HELLO} message containing a random nonce $Ra$. Upon receiving a \texttt{HELLO}, $B$ computes a random nonce, $Ra$, as well, and stores the concatenation of the two. $B$ then waits for a random time $T_w$. The waiting period is introduced to avoid flooding $A$ with responses, as there may be an unknown number of nodes that received the broadcasted \texttt{HELLO} message. After $T_w$, $B$ loads its key $K_{B,A}$ from the pluggable key scheme, and uses this key to authenticate a \texttt{HELLOACK} message containing the computed $R_B$ nonce and the received $R_A$. \gls{mic}s are generated by the 802.15.4 security sublayer, through the use of \gls{ccm}*, which is a modified version of the regular \gls{ccm} allowing for the payload of the frame to be encrypted using \gls{aes} with a 128-bit key \cite{krentz20136lowpan}. \gls{apkes} uses $K_{B,A}$ to authenticate the \texttt{HELLOACK}, and sends it to $A$. Afterwards, $B$ obtains the pairwise key $K'_{B,A}$ for future communication with $A$, by plugging $K_{B,A}$ it into the \gls{aes} algorithm along with the two nonces.

% Hvorfor sjekke at Ra er den samme? Vil ikke det være åpenbart hvis MICen ikke skulle være lik?

When $A$ receives a \texttt{HELLOACK} message, it verifies the attached \gls{mic} by extracting its key $K_{A,B}$ from the pluggable scheme and computing the \gls{mic} for the concatenation of $R_A$ and $R_B$. $A$ then computes the pairwise key for communicating with $B$ by plugging it into the \gls{aes} algorithm. $A$ also checks that the $R_A$ value has not been tampered with, and is equal to the value it initially sent in its \texttt{HELLO} broadcast. The three-way handshake ends with $A$ sending an \texttt{ACK} to $B$ that is authenticated using the pairwise key $K'_{A,B}$. When $B$ receives the \texttt{ACK}, it verifies the \gls{mic} by using its derived pairwise key $K'_{B,A}$. After this process, $A$ and $B$ have successfully agreed upon a shared pairwise key where $K'_{A,B} = K'_{B,A}$, which is to be used for encrypting all future communication between the two nodes.



%In addition to the messages \texttt{HELLO} and \texttt{HELLOACK}, the frames also contains the short addresses for the sending party. These are used

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in APKES]
\begin{align*}
A:\ & Generate\ R_A\ randomly\\
A \rightarrow *:\ & \texttt{HELLO}\langle{R_A}\rangle{}\\
B:\ & Generate\ R_B\ randomly.\ Wait\ for\ T_w \leq M_w\\
B:\ & K_{B,A}\ from\ pluggable\ scheme\\
B \rightarrow A:\ & \texttt{HELLOACK}\langle{R_A, R_B}\rangle{K_{B,A}}\\
B:\ & K'_{B,A}\ =\ AES(K_{B,A}, R_A || R_B)\\
A:\ & K_{A,B}\ from\ pluggable\ scheme\\
A:\ & K'_{A,B}\ =\ AES(K_{A,B}, R_A || R_B)\\
A \rightarrow B:\ & \texttt{ACK}\langle{}\rangle{K'_{A,B}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during APKES' three-way handshake.}
\label{fig:apkes-handshake}
\end{figure}

\subsection{Assumptions of Security Properties}
\label{subsec:apkes-prop}

One of the focuses of \gls{apkes} is to provide authentication of parties during the key establishment process. By inspecting the messages that are exchanged between the two parties in Figure \ref{fig:apkes-handshake}, we observe that no encryption is involved in the handshake, but messages are authenticated by the use of \gls{mic}s. These \gls{mic}s are either computed using $K_{A,B}$ (the pre-shared secret) or $K'_{A,B}$ (the established pairwise key). Therefore, we can assume that entity authentication has to hold for the two communicating parties. Also, as mentioned in Section \ref{sec:attributes}, \emph{implicit} and \emph{explicit} key authentication are two of the other attributes within authentication. For a three-way handshake such as the one used by \gls{apkes}, the initiator achieves \emph{implicit} key authentication, while the responder ($B$) achieves \emph{explicit} key authentication. As the pairwise key is computed from the two nonces that are shared between $A$ and $B$, and the secret from the pluggable scheme (which we assume is secure), both know that the only parties that can compute the pairwise key is those possessing the pre-shared secret, giving them both implicit key authentication. 

$B$ also receives an \texttt{ACK} which is authenticated using the pairwise key $K'_{A,B}$, effectively meaning that $A$ has computed the pairwise key, and which $B$ can confirm by checking the attached \gls{mic}, hence it can be said to achieve explicit key authentication. From $A$'s point of view, however, it has no confirmation of that $B$ has in fact computed the pairwise key, other than it knows it is supposed to (and has to in order to verify the authenticity of the \texttt{ACK}. Also, as \gls{apkes} is a key establishment protocol, the established key is of course claimed to be secret from the adversary.

\subsection{Weaknesses and Challenges with APKES}
\label{subsec:apkes-weakness}

\gls{apkes} establishes a shared symmetric key between nodes, which is used to encrypt and decrypt data that is sent between them. One issue that the protocol does not address is the case where, for some reason, the node is forced to do a reboot. To avoid replay attacks, a node needs to keep control over the frame counters of the nodes it communicates with. These frame counters need to be swapped from the \gls{ram} memory of the device to a non-volatile storage over time. Such storages are for most 802.15.4 devices flash memory, making the swapping process both energy and time consuming \cite{krentz2015handling}. In the Contiki operating system (where \gls{apkes} is implemented), reboot commands are issued whenever processes get stuck or when replacing the battery of the device \cite{dunkels2004contiki}. In the case of a reboot without storing the frame counter, neighbouring nodes would simply discard all messages from the node, as the frame counter would start at zero, and the frames would be considered replayed. Another issue with storing anti-replay data is that \gls{apkes} does not remove information of disappeared neighbours (nor does it discover that a node has left the neighbourhood), which may unnecessarily seize a large part of the node's memory over time.  

In addition to the weaknesses related to frame counters and storing anti-replay protection data, \gls{apkes} has issued related to its usage of temporary and permanent neighbours. As mentioned, the life cycle of a neighbour node ranges from not being associated at all, to becoming a temporary, and finally a permanent neighbour during the key establishment process. However, \gls{apkes} discards \texttt{HELLO} messages from permanent neighbours to prevent \gls{dos} attacks. This means that if a neighbour reboots, it goes into a deadlock with previous neighbours, where it is not able to establish any new keys with these nodes as its \texttt{HELLO}s would silently be discarded. The broadcasting of \texttt{HELLO}s only occurs immediately after the node is booted up, which means that after the node is up and running, it will not attempt to connect to any new neighbours that may have been deployed afterwards. One can argue that it is the responsibility of the post-deployed nodes to establish contact with ``early birds'', but deployed nodes should nevertheless be able to discover new nodes during runtime. 

These issues can be applied into a real life scenario to better understand the limitations of the protocol. Assume a \gls{wsn} for medical applications with multiple devices attached to certain medical equipment. Networks around patient are not necessary stationary, as they may be moved to different facilities in the hospital. Also, certain medical equipment are very expensive, which would encourage reuse and reassignment of the devices (i.e. supporting mobility for these devices may be an important factor for certain cases). 



\section{Adaptable Key Establishment Scheme (AKES)}

The \gls{akes} aims to improve and fix the weaknesses that was introduced in \gls{apkes}, and is currently implemented in the Contiki operating system \cite{krentz2015handling}. Its main goal is to establish session keys between devices in a \gls{6lowpan} network, while being able to withstand reboots and movement from one network to another. As described in Section \ref{subsec:apkes-weakness}, \gls{apkes} suffered from issues when rebooting the device, and it was not able to provide any mobility. Most of these issues can be solved by one ``simple'' adjustment: Establishing session keys between nodes instead of long-term keys. By establishing session keys, \gls{mic}s from previous sessions would be invalidated, which enables node to delete data used for providing replay protection (such as frame counters), and will also filter out old frames. Also, this removes the problem related to frame counters being reset after a reboot, as mentioned in Section \ref{subsec:apkes-weakness}. 

\gls{akes} builds on the approach from \gls{apkes}, where the underlying scheme is pluggable provides \gls{akes} with the pre-shared secret between nodes. Before an 802.15.4 node is able to run \gls{akes}, addressing information (which uniquely identifies a node within an 802.15.4 network and is used by the pluggable scheme when establishing the shared secret) and keying material has to be preloaded into it. \gls{akes} also has access to the same command frames \texttt{HELLO}, \texttt{HELLOACK}, and \texttt{ACK}, which are used to establish session keys, and only processed by the data link layer. Figure \ref{fig:6lowpan-krentz} describes where \gls{apkes} is implemented in the \gls{6lowpan} stack, and as \gls{akes} is merely an improvement over \gls{apkes}, it is implemented on the same layer as the 802.15.4 Security Sublayer. 

As in \gls{apkes}, \gls{akes} also utilizes a differentiation between non-neighbours, temporary neighbours, and permanent neighbours. When a node sends a \texttt{HELLO} it will obtain a status as a temporary node at the receiver. This status will be changed to permanent upon receipt of an authentic \texttt{ACK} message as part of the final step in the session key establishment. Keep in mind that one of the issues with \gls{apkes} was the deadlock state rebooted nodes would start in with previously permanent neighbours. In \gls{akes}, permanent neighbours who transmits a \texttt{HELLO} message will obtain a status as a temporary neighbour in addition to its old permanent neighbour status, until the \texttt{ACK} is received. After receiving the \texttt{ACK}, the permanent neighbour status is deleted and the temporary is turned into a permanent one, which effectively renews the session between the two nodes. When a permanent neighbour(i.e. a session key) is established, the neighbour is assigned an expiration time where the key becomes invalid. The lime time of a session is, however, prolonged for each received, authentic frame from the particular session, and can also be prolonged by issuing certain commands. 

\gls{akes} introduces two tasks for preventing deadlocks and increasing mobility for devices, while still keeping \gls{dos} attacks in mind: Periodically pinging its permanent neighbours to delete disappeared nodes, and discover new neighbours by routinely broadcasting \texttt{HELLO}s. When a session with a neighbour expires, the node issues an authenticated \texttt{UPDATE} command and sends it to the node, which potentially responds with an \texttt{UPDATEACK}. A received \texttt{UPDATEACK} leads to both parties of the session extending the lifetime of their key, while the absence of such an acknowledgement, it will try a few times before eventually giving up and deleting the neighbour from its view of the network.

Trickle, which is an algorithm for distributing information in \gls{wsn}s \cite{levis2011trickle}, is adopted by \gls{akes} for discovering new neighbours in a routinely matter. The challenge is to define \emph{how} often the node should broadcast \texttt{HELLO}s in order to discover new nodes and changes to the network topology, which Trickle aim to solve by applying different network statistics into its algorithm.

\begin{figure}[h]
\begin{tcolorbox}[title=Three-way handshake in AKES]
\begin{align*}
A:\ & Generate\ R_A\ randomly\\
A \rightarrow *:\ & \texttt{HELLO}\langle{PAN_A, ID_A, R_A, C_A}\rangle{}\\
B:\ & K_{B,A}\ from\ pluggable\ scheme\\
B:\ & Generate\ R_B\ randomly.\ Wait\ for\ T_w \leq M_w\\
B:\ & K'_{B,A}\ =\ AES(K_{B,A}, R_A || R_B)\\
B \rightarrow A:\ & \texttt{HELLOACK}\langle{PAN_A, ID_A, PAN_B, ID_B, R_B, I_{A,B}, C_B, P_A}\rangle{K_{B,A}}\\
A:\ & K_{A,B}\ from\ pluggable\ scheme\\
A:\ & K'_{A,B}\ =\ AES(K_{A,B}, R_A || R_B)\\
A \rightarrow B:\ & \texttt{ACK}\langle{PAN_B, ID_B, PAN_A, ID_A, I_{B,A}, C_A}\rangle{K'_{A,B}}
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during AKES' three-way handshake.}
\label{fig:akes-handshake}
\end{figure}

\subsection{Protocol Specification}

In \gls{akes}, the key establishment process consists of a three-way handshake where the two nodes establish a session key, as described in Figure \ref{fig:akes-handshake}. Initially, the node $A$ broadcasts a \texttt{HELLO} message to its neighbours containing a randomly generated nonce value $R_A$ along with the identity of the node, its \gls{pan} address, and the frame counter $C_A$. The \texttt{HELLO} broadcast is authenticated using \gls{ebeap} \cite{krentz20136lowpan}, which is a protocol for authenticating broadcast frames in \gls{6lowpan} networks, or a pre-distributed group session key. When $B$ receives a \texttt{HELLO} broadcast, generates a random nonce as well, denoted as $R_B$. It then proceeds to request the shared secret $K_{B,A}$ from its pluggable scheme, and uses this key to derive the pairwise session key $K'_{B,A}$ as $AES-128(K_{B,A}, R_A || R_B)$. $B$ then crafts a \texttt{HELLOACK} response which is sent to $A$ containing $R_B$. The \texttt{HELLOACK} is authenticated by adding a \gls{mic} generated with $K_{B,A}$, in addition to $B$'s \gls{pan} address, identity, and other values related to frame counters and \gls{ebeap} authentication. In the response, $B$ attaches a field $P_A$ as well to indicate whether or not $A$ is currently registered as a permanent neighbour of $B$, and is also capable of piggybacking group session keys. If the $P_A$ field is set, $A$ can choose to disconnect from the establishment, which would be normal if the \texttt{HELLO} was just a routine broadcast. Upon receiving the \texttt{HELLOACK}, $A$ validates the attached \gls{mic} by computing the pairwise session key $K'_{A, B}$ in the same manner as $B$. After this, future communication  is encrypted using the shared pairwise session key until it expires.


\subsection{Assumptions of Security Properties}






\section{Secure Authentication and Key Establishment Scheme}

The third, and last protocol which will be discussed in this thesis, is the \gls{sakes}. \gls{sakes} is claimed to provide secure authentication and key establishment for nodes in a device-to-device network running on \gls{6lowpan} \cite{hussen2013sakes}. Previous described protocols such as \gls{apkes} and \gls{akes} enables devices to directly communicate with each other without any previous authentication have taken place. The architecture in \gls{sakes} as seen in Figure \ref{fig:sakes-arch} consists of end devices, \gls{6lowpan} routers, \gls{6lowpan} border routers, and remote servers providing services to the devices. End devices are typically sensors, with very limited computational power. Routers are more powerful, 




Authentication
-works


Key establishment
- assumptions
- what is wrong
- correct to something that is modellable

\begin{figure}
	\centering
	\includegraphics[scale=0.50]{sakes-arch.png}
	\caption{Caption goes here}
	\label{fig:sakes-arch}
\end{figure}

\subsection{Protocol Specification}

\begin{figure}[h]
\begin{tcolorbox}[title=Authentication in SAKES]
\begin{align*}
A:\ & Generate\ N_A\ randomly\\
A \rightarrow B:\ & N_A\\
B:\ & Generate\ N_B\ randomly\\
B \rightarrow A:\ & \{N_A\}_{K_{AB}}\\
A:\ & Construct\ C_{A}:\ \{ID_A, ID_B, ID_D\}_{K_{AC}}\\
A \rightarrow B:\ & \{C_A, ID_A, N_A\}_{K_{AB}}\\
B \rightarrow C:\ & \{C_A, ID_B, N_B\}_{K_{BC}}\\
C:\ & Verify\ the\ identity\ of\ A,\ B,\ and\ D\\
C: \ & Construct\ C_C: \{ID_A, ID_B, ID_D\}_{Kpriv_{C}}\\
C:\ & Generate\ N_C\ randomly\ and\ a\ public\ key\ pair\ (Pk_B, Sk_B)\\
C \rightarrow B:\ & \{N_C, C_C, Pk_B, Sk_B\}_{K_{BC}}\\
C \rightarrow A:\ & \{ID_B, N_C\}_{K_{AC}}\\
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between the end device (A), router (B), and authentication module (C) during SAKES' authentication phase.}
\label{fig:sakes-auth}
\end{figure}



\begin{figure}[h]
\begin{tcolorbox}[title=Key Establishment in SAKES]
\begin{align*}
B \rightarrow D:\ & \{C_C, N_B, P_K, B\}_{Sk_B} \\
D:\ & Calculate\ Session\ Key\ (SK_D):\ SK_D = g^{Pk_C * Sk_D} \mod{P}\\
D:\ & Generate\ N_D\ randomly\\
D \rightarrow B:\ & \{Pk_D, P, g, N_D, \}_{Sk_D}\\
B:\ & Calculate\ Session\ Key\ for\ A\ (SK_A):\ SK_A = g^{Pk_D * Sk_C} \mod{P}\\
B \rightarrow A:\ & \{SK_A, N_B\}_{K_{AB}}\\
Claim:\ & SK_A = SK_D\\
\end{align*}
\end{tcolorbox}
\caption{Figure of the messages sent between communicating parties during SAKES key establishment between the end device (A), the 6LoWPAN router (B), and the remote server (D).}
\label{fig:sakes-keys}
\end{figure}


\subsection{Assumptions of Security Properties}



% How to check for properties:

% Forward Secrecy: Not able to achieve in symmetric key. Check through Scyther rules.

% Known-Key Security: Session-Key reveal

% Key Confirmation: running, commit / niagree

% Key Compromise Impersonation: Impossible to achieve in protocols relying on symmetric keys? Need asymmetric? Boyd book. SKR claim of an entity whose long-term key is revealed to the adversary

% Unknown key share: Known-Key Security?

% Entity authentication: From A to B: Aliveness of A in B's claims.

% Implicit: Long-term reveal for other entities than A and B.

% Explicit. Implicit + key confirmation
